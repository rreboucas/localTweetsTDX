public with sharing class localTweetsServerController {
    
    @AuraEnabled
    public String createdAt { get;set; }
    @AuraEnabled
    public String tweetId { get;set; }
    @AuraEnabled
    public String text { get;set; }
    @AuraEnabled
    public String url { get;set; }
    @AuraEnabled
    public String twitterHandle { get;set; }
    @AuraEnabled
    public String street { get;set; }
    @AuraEnabled
    public String city { get;set; }
    @AuraEnabled
    public String state { get;set; }

    @AuraEnabled(cacheable=true)
    public static localTweetsServerController getLocationAddress(String locationID) {
        localTweetsServerController obj = new localTweetsServerController();

        System.Debug('##### locationID: ' + locationID);

        Sobject address;
        String soql = 'SELECT City,Country,State,Street from Address WHERE ParentId = ' + ' \'' + locationID +'\'' + ' and isDeleted = false order by createddate desc limit 1';
        System.Debug('##### soql: ' + soql);
        if (String.isNotEmpty(locationID))
            address = Database.query(soql);

        if (address != null)
        {
            System.Debug('##### address is not null: ' + address);
            obj.street = (String)address.get('Street');
            obj.city = (String)address.get('City');
            obj.state = (String)address.get('State');
            
        }
        return obj;

    }

    @AuraEnabled(cacheable=true)
    public static localTweetsServerController getTwitterAccounts(String cityState) {
        localTweetsServerController obj = new localTweetsServerController();

        TwitterApp__mdt twitterSecret = [SELECT APISecret__c,APIKey__c, AccessToken__c, TokenSecret__c FROM TwitterApp__mdt limit 1];

        String apiKey = twitterSecret.APIKey__c;        
        String apiSecret = twitterSecret.APISecret__c;
        String accesToken = twitterSecret.AccessToken__c;        
        String accesTokenSecret = twitterSecret.TokenSecret__c;

        String oathNonce = twitterHelper.generateOathNonce();
        Long timestamp = twitterHelper.generateTimeStamp();
        //oauth_signature parameter contains a value which is generated by running all of the other request 
        //parameters and two secret values through a signing algorithm
        String signature = '';
        String othSecret = Encodingutil.urlEncode(accesTokenSecret, 'UTF-8');
        String consumSecret = Encodingutil.urlEncode(apiSecret, 'UTF-8');
        String othToken = Encodingutil.urlEncode(accesToken, 'UTF-8');
        String othNonce = Encodingutil.urlEncode(oathNonce, 'UTF-8');
        String consumKey = Encodingutil.urlEncode(apiKey, 'UTF-8');

        String queryValue = Encodingutil.urlEncode('City of' + cityState, 'UTF-8');

        String paramString = 'include_entities=true&'+
                                 'oauth_consumer_key='+consumKey+'&'+
                                 'oauth_nonce='+othNonce+'&'+
                                 'oauth_signature_method=HMAC-SHA1&'+
                                 'oauth_timestamp='+timestamp+'&'+
                                 'oauth_token='+othToken+'&'+
                                 'oauth_version=1.0&'+
                                 'q='+ queryValue;
        
        string baseString = 'GET&'+EncodingUtil.urlEncode('https://api.twitter.com/1.1/users/search.json', 'UTF-8')+'&'+ 
        EncodingUtil.urlEncode(paramString, 'UTF-8');
        string signString = consumSecret+'&'+othSecret;
        blob blobBaseString = Blob.ValueOf(baseString);
        blob blobSignString = Blob.ValueOf(signString);
        blob signBlob = crypto.generateMac('hmacSHA1',blobBaseString ,blobSignString );        
        signature =  EncodingUtil.base64Encode(signBlob);

        if(String.isNotBlank(signature))
        {
            signature = Encodingutil.urlEncode(signature, 'UTF-8');
            HttpRequest req = new HttpRequest();
            req.setEndpoint('https://api.twitter.com/1.1/users/search.json?q='+ queryValue);
            req.setMethod('GET');
            string reqstring = 'OAuth oauth_consumer_key="'+consumKey+'",'+
                                'oauth_nonce="'+othNonce+'",'+
                                'oauth_signature="'+signature +'",'+
                                'oauth_signature_method="HMAC-SHA1",'+
                                'oauth_timestamp="'+timestamp+'",'+
                                'oauth_token="'+othToken+'",'+
                                'oauth_version="1.0"';
            system.debug('### req String :'+reqstring);
            req.setHeader('authorization',reqstring);
            //req.setBody('q='+ queryValue);
            if(!Test.isRunningTest())
            {
                Http http = new Http();
                HTTPResponse res = http.send(req);
                system.debug('####### Twitter Response: ' + res.getBody());
            }

        }

        return obj;
    }

    @AuraEnabled(cacheable=true)
    public static List<localTweetsServerController> getOfficialsTweets(String locationId) {

        // If Location Id is null, fetch location ID for the countru - TODO: make it dynamic
        if(String.isEmpty(locationId))
        {
            Sobject masterLocation;
            String soql = 'SELECT Id FROM Location where name = ' + ' \'' + 'US' +'\'' + ' and LocationType = ' + ' \'' + 'Site' +'\'' + ' order by createddate desc limit 1';
            System.Debug('##### soql: ' + soql);
            masterLocation = Database.query(soql);

            if (masterLocation != null)
            {
                locationId = (String)masterLocation.get('Id');
                System.Debug('##### location is null - master location ID: ' + locationId);
            }
        }
            

        List<localTweetsServerController> lstReturnRecs = new List<localTweetsServerController>();

        //TwitterApp__mdt twitterSecret = [SELECT Token_Secret__c,Token__c FROM TwitterApp__mdt limit 1];
        TwitterApp__mdt twitterSecret = [SELECT APISecret__c,APIKey__c FROM TwitterApp__mdt limit 1];
        
        /* ------------ Start: Fetch list of Twitter Hanles for Location: ----------------- */
        List<Twitter_Handle__c> lstTwHandlers = [Select name from Twitter_Handle__c where Location__c =: locationId];
        system.debug('####### Twitter Handlers: ' + lstTwHandlers);

        String strFromQuery;
        if (!lstTwHandlers.isEmpty())
        {
            // 1. Add Risks keyword - TODO: Make it dynamic passing risks keywords defined in Work.com
            
            strFromQuery = Encodingutil.urlEncode('(corona OR covid OR order OR covid-19 OR reopen OR open OR closed OR closure OR lockdown OR stay-at-home OR phase OR restriction) (', 'UTF-8');

            // 2. Add Twitter handles for the location
            Integer count = 0;
            for (Twitter_Handle__c h: lstTwHandlers)
            {
                if (count > 0)
                    strFromQuery = strFromQuery + Encodingutil.urlEncode(' OR ', 'UTF-8');
                strFromQuery = strFromQuery + 'from' + Encodingutil.urlEncode(':' + h.name, 'UTF-8');
                count++;
            }
            strFromQuery = strFromQuery + ')';           

            // 3. Add limits
            strFromQuery = strFromQuery + '&result_type=recent&count=10';
            system.debug('####### strFromQuery: ' + strFromQuery);
        }

        /* ------------ End: Fetch list of Twitter Hanles for Location: ----------------- */

        /* ------------ Start: authenticate to Twitter - Retrieve Bearer Token: ----------------- */
        String oauthConsumerKey = twitterSecret.APIKey__c;        
        String oauthConsumerSecret = twitterSecret.APISecret__c;

        String baseUrl = 'https://api.twitter.com';
        String oauthSignatureMethod = 'HMAC-SHA1';
            
        String keyencoded = EncodingUtil.urlEncode(oauthConsumerKey, 'UTF-8');
        String secretkeyencoded = EncodingUtil.urlEncode(oauthConsumerSecret, 'UTF-8');
        
        //Create Final Key String
        String sFinal = keyencoded + ':' + secretkeyencoded;
        //Convert to Blob
        Blob headerValue = Blob.valueOf(sFinal);
        
        //Build Request
        HttpRequest req = new HttpRequest();
        req.setEndpoint('https://api.twitter.com/oauth2/token');
        req.setMethod('POST');
        
        //Add Auth Header
        String authorizationHeader = 'Basic ' + EncodingUtil.base64Encode(headerValue);
        req.setHeader('Authorization', authorizationHeader);
        
        //You need to add this to the request - proved easy to miss in instructions...
        req.setBody('grant_type=client_credentials');
        
        //Make request
        Http http = new Http();
        HTTPResponse res = http.send(req);
        String responseBody = res.getBody();
        System.debug('########## Twitter authentication responseBody : ' + responseBody);
        String stoken;
        //Parse JSON for Bearer Token
        JSONParser parser = JSON.createParser(res.getBody());
        while (parser.nextToken() != null) {
            if (parser.getCurrentToken() == JSONToken.FIELD_NAME && parser.getText() == 'access_token'){
            parser.nextToken();
            stoken = parser.getText();
            System.debug('########## bearer token : ' + stoken);
            }
        }

         /* ------------ End: authenticate to Twitter: - Retrieve Bearer Token ----------------- */

        /* ------------ Start: fetch and parse tweets from Local Authorities for the location: ----------------- */
 
        HttpRequest req2 = new HttpRequest();
        //I actually store the endpoint in the same custom setting and build dynamically, but for purposes of demo:
        //req2.setEndpoint('https://api.twitter.com/1.1/users/search.json?q=' + 'city of ' + cityState);
       
        req2.setEndpoint('https://api.twitter.com/1.1/search/tweets.json?q=' + strFromQuery);
        req2.setMethod('GET');
    
        //Call Bearer token Method
        //Note - unless invalidated, I believe you can store this and keep using it indefinitely, but again, to demo concept
        String authorizationHeader2 = 'Bearer ' + stoken;
        req2.setHeader('authorization', authorizationHeader2);
    
        Http http2 = new Http();
        HTTPResponse res2 = http2.send(req2);
        System.debug('########## res2 : ' + res2);
        String sBody2 = res2.getBody();
        System.debug('########## sBody2 : ' + sBody2);

        // Parse Json response:
        


        getTweets recs = (getTweets) JSON.deserialize(sBody2, getTweets.class);
        System.debug('########## recs : ' + recs);
        for (Tweet t: recs.statuses){
            localTweetsServerController obj = new localTweetsServerController();
            obj.createdAt = t.created_at;
            obj.tweetId = t.id_str;
            obj.text = t.text;
            obj.twitterHandle = t.user.screen_name;
            System.debug('########## obj : ' + obj);
            lstReturnRecs.add(obj);
        }


        /* ------------ End: fetch and parse tweets from Local Authorities for the location: ----------------- */
        System.debug('########## lstReturnRecs size : ' + lstReturnRecs.size());
        System.debug('########## lstReturnRecs : ' + lstReturnRecs);
        return lstReturnRecs;
    }

    public class getTweets {
        public List<Tweet> statuses {get;set;}
    }

    public class Tweet{
        public String created_at {get;set;}
        public String id_str {get;set;}
        public String text {get;set;}
        public User user {get;set;}
        //public Retweet retweeted_status {get;set;}
    }
    public class User{
        public String screen_name {get;set;}
    }

    /*
    public class Retweet{
        public Entities entities {get;set;}
    }

    public class Entities{
        public Urls urls {get;set;}
    }

    public class Urls{
        public String url {get;set;}
    } */
}
